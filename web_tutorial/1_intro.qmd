---
title: "Introduction"  
---

## Nextflow training materials

::: callout-tip
There is a great community around nextflow, and tons of training material exist for all levels of experience with it. This workshop is heavily based on materials provided in those courses, assembled to my personal preferences. I sincerely encourage you to learn nextflow on your own using the materials available on the [official nextflow training website](https://training.nextflow.io/latest/ "Nextflow community training portal").
:::

## Learning objectives

By the end of this workshop you should be able to:

-   Write a simple Nextflow **workflow**

-   Have basic understanding of the concepts of **Channels**, **Processes** and **Operators**

-   Run an test nf-core pipeline

-   Know where to go next ðŸ¤·

## The problem

Lets say we want to do the following, as I am sure you have done many times before:

We will start with fastq data and perform trimming, after which we will perform fastqc.

![](images/clipboard-1893698979.png)

### Solution - bash

In bash we would do this:

``` {code-fold="false"}
fastp --in1 liver_1.fq \
      --in2 liver_2.fq \
      --out1 liver_1.trimmed.fq \
      --out2 liver_2.trimmed.fq \
      -h liver.html 

fastqc liver_1.fq
fastqc liver_1.trimmed.fq
```

But of course, it will fail since we do not have fastp and fastqc installed.

::: callout-tip
Good practice is to use containers which will enable reproducibility. Building dockerfiles and images is sometimes tricky, but also could be defying the purpose of reproducible research. You can find many already available dockers/singularity images at [dockerhub](https://hub.docker.com/r/biocontainers/) and [quay.io](https://quay.io) .
:::

### Use containers!

We will use the docker for fastp and fastqc available on dockerhub:

First; pull the container locally:

```{bash, eval=FALSE}
docker pull biocontainers/fastqc:v0.11.9_cv8
```

Next, enter the container image:

```{bash, eval=FALSE}
docker run -v .:/data -it biocontainers/fastqc:v0.11.9_cv8
```

#### Explanation

+----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| command                          | explained                                                                                                                                                                                                                                                                                                          |
+==================================+====================================================================================================================================================================================================================================================================================================================+
| docker run                       | This is the basic Docker command used to create and start a new container from a specified image.                                                                                                                                                                                                                  |
+----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -v .:/data                       | This flag mounts a volume. Here, the current directory (represented by .) on your host machine is mapped to the /data directory inside the container. This means any files in your current directory will be accessible in /data within the container, and changes made there will be reflected back on your host. |
+----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -i (interactive)                 | Keeps STDIN open so you can interact with the container.                                                                                                                                                                                                                                                           |
+----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| -t (tty)                         | Allocates a pseudo-TTY, which provides a terminal session inside the container.\                                                                                                                                                                                                                                   |
|                                  | Together, they allow you to run the container in interactive mode, making it easier to execute commands and see outputs.                                                                                                                                                                                           |
+----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+
| biocontainers/fastqc:v0.11.9_cv8 | This is the Docker image being used. It specifies: image and tag.                                                                                                                                                                                                                                                  |
+----------------------------------+--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------+

: If we wanted to do this on multiple files we could write a bash script:

```{bash, eval=FALSE}
```

Lets try to run it on our 4 samples:

...

![](images/clipboard-375543568.png)

## My first nextflow script

``` nextflow

nextflow.enable.dsl=2


workflow {
  
  // parse input:
    infile = params.infile
  infile_channel = Channel.fromList( infile )
  
  // run FASTQC:
  FASTQC(infile_1_channel, infile_2_channel)

}


process FASTQC {
    
    label 'fastqc'
    
    input:
    path infilename

    output:
    path '*' 
        
    shell:
  '''
  fastqc !{infilename}  
  '''
}
```

## Processes and Channels

Nextflow workflow is made by joining together different processes. Each process can be written in any scripting language that can be executed by the Linux platform (Bash, Perl, Ruby, Python, etc.).

![](images/clipboard-1373747047.png)

Processes are executed independently and are isolated from each other. The only way they can communicate is via "channels", asynchronous first-in, first-out (FIFO) queues. In other words, every input and output of a process is represented as a channel. The interaction between these processes, and ultimately the workflow execution flow itself, is implicitly defined by these input and output declarations.

```{r, eval=FALSE}

#!/usr/bin/env nextflow

params.greeting = 'Hello world!' #| This sets a greeting message
greeting_ch = Channel.of(params.greeting) #| Creates a Nextflow channel from the greeting

process SPLITLETTERS {
    input:
    val x #| Takes a single input value

    script:
    """
    echo $x | fold -w1
    """
}
```